## 一直对于递归的思想有所疑惑
通过调试发现，可将递归理解成对于(二叉)树每个分支的搜寻过程  
![img.png](img.png)  
以此处作为例子，递归就会将程序一层层进入到树的最左端的底部(从底部向上执行)，然后搜索完左子树，再搜索右子树  

**递归的模板**

```c++
void f(){
     if(符合边界条件){
       ///////
        return;
     }
     //某种形式的调用
     f();
}
```

**回溯的模板**

```c++
void dfs(int 当前状态){
    if(当前状态为边界状态)
    {
        记录或输出
            return;
    }
    for(i=0;i<n;i++){		//横向遍历解答树所有子节点
        //扩展出一个子状态。
        修改了全局变量
            if(子状态满足约束条件)
            {
                dfs(子状态)
            }
        恢复全局变量//回溯部分
    }
}
```

**BFS模板**

```c++
queue<type> q;
q.push(初始状态);
while (!q.empty())
{
  type t = q.front() ;
  q.pop();
  遍历 t 的各个Next状态  next
  { 
    if (next is legal)
      q.push(next); 计数或维护等; 
  } 
}
```

**DFS模板**

```c++
DFS（顶点） 
{
　　处理当前顶点，记录为已访问
　　遍历与当前顶点相邻的所有未访问顶点
　　{
　　　　　　标记更改;
　　　　　　DFS( 下一子状态);
　　　　　　恢复更改;
　　}
}
```

